
from itertools import combinations
from numpy.random import uniform

from dynamite.operators import op_sum, op_product
from dynamite.extras import majorana


def build_hamiltonian_simple(N):
    '''
    This function is the most straightforward way to generate the 
    Hamiltonian, but it's not nearly as fast as build_hamiltonian
    below. We still include it as an example.
    '''
    H = 0
    for i in range(N):
        for j in range(i+1, N):
            for k in range(j+1, N):
                for l in range(k+1, N):
                    Jijkl = uniform(-1, 1)
                    prod = majorana(i)*majorana(j)*majorana(k)*majorana(l)
                    H += Jijkl*prod
                    
    return H
    

def build_hamiltonian(N):
    '''
    This function builds the SYK Hamiltonian. It is not the simplest
    way of implementing it, but demonstrates some techniques for quickly
    building operators that have a lot of terms
    '''
    
    # TODO: seed!
    
    # only compute each of the majoranas once, for speed
    majoranas = [majorana(i) for i in range(N)]

    # This function yields a Python generator, which produces the terms of 
    # the Hamiltonian
    def gen_products(N):
        for idxs in combinations(range(N), 4):
            # product of the four majoranas
            p = op_product(majoranas[idx] for idx in idxs)
            
            # random value. same on each rank because we set the seed above
            Jijkl = uniform(-1, 1)
            p.scale(Jijkl)
            
            yield p

    # op_sum iterates through the terms generated by gen_products, and sums
    # them as quickly as possible
    return op_sum(gen_products(N))
